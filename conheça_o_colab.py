# -*- coding: utf-8 -*-
"""Conhe√ßa o Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# C√©lula 1 ‚Äî Instala depend√™ncias e cloudflared
!pip install streamlit pandas plotly openpyxl -q
# Baixa e instala cloudflared (usado para gerar link p√∫blico .trycloudflare.com)
!wget -q -O cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
!dpkg -i cloudflared.deb || apt-get -y -qq -f install

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import io
# import plotly.graph_objs as go
# 
# # ---------- Config / T√≠tulo ----------
# st.set_page_config(page_title="Simulador de Despesa com Pessoal (LRF)", layout="wide")
# st.title("üìä Simulador de Despesa com Pessoal (LRF) - Limites M√°ximo/Prudencial/Alerta")
# 
# # ---------- Utilit√°rios ----------
# def fmt_r(x):
#     try:
#         return f"R$ {x:,.2f}"
#     except:
#         return "-"
# 
# def calc_limits(rcl_adj, max_pct, prud_factor, alert_factor):
#     limite_max = rcl_adj * max_pct
#     limite_prud = limite_max * prud_factor
#     limite_alert = limite_max * alert_factor
#     return limite_max, limite_prud, limite_alert
# 
# def compute_adjustments(rcl, desp, max_pct, prud_factor, alert_factor):
#     """Para cada limite retorna redu√ß√£o necess√°ria (R$ e %) e aumento de RCL necess√°rio (R$ e %)"""
#     res = {}
#     nomes = ["M√°ximo","Prudencial","Alerta"]
#     fatores = [1.0, prud_factor, alert_factor]
#     for nome, f in zip(nomes, fatores):
#         limite = rcl * max_pct * f
#         if desp > limite:
#             reduce_R = desp - limite
#             reduce_pct = (reduce_R / desp * 100) if desp else np.nan
#         else:
#             reduce_R = 0.0
#             reduce_pct = 0.0
#         denom = max_pct * f
#         if denom > 0:
#             rcl_needed = desp / denom
#             rcl_increase_R = max(0.0, rcl_needed - rcl)
#             rcl_increase_pct = (rcl_increase_R / rcl * 100) if rcl else np.nan
#         else:
#             rcl_increase_R = np.nan
#             rcl_increase_pct = np.nan
#         res[nome] = {
#             "limite": limite,
#             "reduce_R": reduce_R,
#             "reduce_pct": reduce_pct,
#             "rcl_increase_R": rcl_increase_R,
#             "rcl_increase_pct": rcl_increase_pct
#         }
#     return res
# 
# # ---------- Sidebar: upload ou manual (valores padr√£o vindos da imagem) ----------
# st.sidebar.header("‚öôÔ∏è Entradas / Upload")
# 
# uploaded = st.sidebar.file_uploader("üì• (Opcional) Upload XLSX com RCL/Despesa (colunas: RCL_adjusted, Despesa_Pessoal)", type=["xlsx"])
# if uploaded:
#     try:
#         df_up = pd.read_excel(uploaded)
#         # tenta mapear nomes de coluna
#         if "RCL_adjusted" in df_up.columns:
#             rcl_default = float(df_up["RCL_adjusted"].iloc[0])
#         elif "RCL ajustada" in df_up.columns:
#             rcl_default = float(df_up["RCL ajustada"].iloc[0])
#         else:
#             rcl_default = 36273923688.14
#         if "Despesa_Pessoal" in df_up.columns:
#             desp_default = float(df_up["Despesa_Pessoal"].iloc[0])
#         elif "Despesa com Pessoal" in df_up.columns:
#             desp_default = float(df_up["Despesa com Pessoal"].iloc[0])
#         else:
#             desp_default = 15127218477.20
#         st.sidebar.success("Planilha carregada ‚Äî valores usados como padr√£o.")
#     except Exception as e:
#         rcl_default = 36273923688.14
#         desp_default = 15127218477.20
#         st.sidebar.error("Erro ao ler XLSX ‚Äî usando valores padr√£o.")
# else:
#     # Valores padrao conforme imagem enviada
#     # RCL (ajustada para c√°lculo): 36.273.923.688,14
#     # Despesa com pessoal (DTP): 15.127.218.477,20
#     rcl_default = 36273923688.14
#     desp_default = 15127218477.20
# 
# st.sidebar.subheader("Par√¢metros Atuais")
# rcl_atual = st.sidebar.number_input("RCL ajustada (Atual) (R$)", value=rcl_default, format="%.2f", min_value=0.0)
# desp_atual = st.sidebar.number_input("Despesa com Pessoal (Atual) (R$)", value=desp_default, format="%.2f", min_value=0.0)
# 
# st.sidebar.markdown("---")
# st.sidebar.subheader("Par√¢metros dos Limites (padr√£o da imagem)")
# max_pct = st.sidebar.number_input("Limite M√°ximo (% RCL)", value=0.49, min_value=0.0, max_value=1.0, step=0.01, format="%.2f")
# prud_factor = st.sidebar.number_input("Fator Prudencial (fra√ß√£o do m√°ximo)", value=0.95, min_value=0.0, max_value=1.0, step=0.01, format="%.2f")
# alert_factor = st.sidebar.number_input("Fator Alerta (fra√ß√£o do m√°ximo)", value=0.90, min_value=0.0, max_value=1.0, step=0.01, format="%.2f")
# 
# st.sidebar.markdown("---")
# st.sidebar.subheader("üéØ Simula√ß√£o (Cen√°rio Simulado)")
# sim_type = st.sidebar.selectbox("Tipo de simula√ß√£o", (
#     "Nenhuma",
#     "Aumento despesa (%)", "Aumento despesa (R$)",
#     "Redu√ß√£o despesa (%)", "Redu√ß√£o despesa (R$)",
#     "Aumento receita (%)", "Aumento receita (R$)",
#     "Redu√ß√£o receita (%)", "Redu√ß√£o receita (R$)"
# ))
# sim_val = st.sidebar.number_input("Valor da simula√ß√£o (percentual ou R$)", value=0.0, format="%.2f")
# 
# # ---------- Calcula cen√°rio Atual e Simulado ----------
# rcl = {"atual": float(rcl_atual), "sim": float(rcl_atual)}
# desp = {"atual": float(desp_atual), "sim": float(desp_atual)}
# 
# if sim_type == "Aumento despesa (%)":
#     desp["sim"] = desp_atual * (1 + sim_val/100.0)
# elif sim_type == "Aumento despesa (R$)":
#     desp["sim"] = desp_atual + sim_val
# elif sim_type == "Redu√ß√£o despesa (%)":
#     desp["sim"] = desp_atual * (1 - sim_val/100.0)
# elif sim_type == "Redu√ß√£o despesa (R$)":
#     desp["sim"] = max(0.0, desp_atual - sim_val)
# elif sim_type == "Aumento receita (%)":
#     rcl["sim"] = rcl_atual * (1 + sim_val/100.0)
# elif sim_type == "Aumento receita (R$)":
#     rcl["sim"] = rcl_atual + sim_val
# elif sim_type == "Redu√ß√£o receita (%)":
#     rcl["sim"] = rcl_atual * (1 - sim_val/100.0)
# elif sim_type == "Redu√ß√£o receita (R$)":
#     rcl["sim"] = max(0.0, rcl_atual - sim_val)
# 
# # limites Atual e Simulado
# lim_atual = calc_limits(rcl["atual"], max_pct, prud_factor, alert_factor)
# lim_sim = calc_limits(rcl["sim"], max_pct, prud_factor, alert_factor)
# 
# # ajustes (para o cen√°rio simulado)
# ajustes = compute_adjustments(rcl["sim"], desp["sim"], max_pct, prud_factor, alert_factor)
# 
# # ---------- Vis√£o r√°pida (Gauge + Ajustes compactos) ----------
# st.header("üìå Vis√£o r√°pida")
# col_g1, col_g2 = st.columns([1.6, 1])
# 
# pct_atual = (desp["atual"] / lim_atual[0] * 100) if lim_atual[0] else np.nan
# pct_sim = (desp["sim"] / lim_sim[0] * 100) if lim_sim[0] else np.nan
# 
# with col_g1:
#     fig_g = go.Figure(go.Indicator(
#         mode="gauge+number+delta",
#         value=round(pct_sim,2) if not np.isnan(pct_sim) else 0,
#         delta={'reference': round(pct_atual,2) if not np.isnan(pct_atual) else 0},
#         title={'text': "Simulado % do Limite M√°ximo"},
#         gauge={
#             'axis': {'range': [0, 120]},
#             'bar': {'color': "orange"},
#             'steps': [
#                 {'range': [0, 90], 'color': "lightgreen"},
#                 {'range': [90, 95], 'color': "yellow"},
#                 {'range': [95, 120], 'color': "red"}
#             ]
#         }
#     ))
#     fig_g.update_layout(height=300)
#     st.plotly_chart(fig_g, use_container_width=True)
# 
# with col_g2:
#     st.markdown("### üîß Ajustes necess√°rios (Cen√°rio Simulado)")
#     rows = []
#     for nome in ["M√°ximo","Prudencial","Alerta"]:
#         a = ajustes[nome]
#         # compactar texto sem poluir
#         reduce_txt = f"{fmt_r(a['reduce_R'])} ({a['reduce_pct']:.2f}%)" if a['reduce_R']>0 else "‚Äî"
#         rcl_txt = f"{fmt_r(a['rcl_increase_R'])} ({a['rcl_increase_pct']:.2f}%)" if a['rcl_increase_R']>0 else "‚Äî"
#         rows.append({"Limite": nome, "Reduzir Despesa (R$ / %)": reduce_txt, "Aumentar RCL (R$ / %)": rcl_txt})
#     st.table(pd.DataFrame(rows).set_index("Limite"))
# 
# st.markdown("---")
# 
# # ---------- Dashboards ‚Äî todos na tela inicial ----------
# st.header("üìä Dashboards ‚Äî Atual vs Simulado")
# 
# # 1) Limites: compara√ß√£o Atual vs Simulado (horizontal grouped bars)
# lim_df = pd.DataFrame({
#     "Limite": ["M√°ximo","Prudencial","Alerta"],
#     "Atual": list(lim_atual),
#     "Simulado": list(lim_sim)
# })
# fig_lim = go.Figure()
# fig_lim.add_trace(go.Bar(x=lim_df["Atual"], y=lim_df["Limite"], orientation='h', name="Atual", marker=dict(color="lightgray")))
# fig_lim.add_trace(go.Bar(x=lim_df["Simulado"], y=lim_df["Limite"], orientation='h', name="Simulado", marker=dict(color="darkgray")))
# fig_lim.update_layout(height=320, barmode='group', xaxis_title="R$ (reais)")
# st.plotly_chart(fig_lim, use_container_width=True)
# st.caption("Compara√ß√£o dos limites (Atual vs Simulado).")
# 
# # 2) Despesa: Atual vs Simulado (barra simples)
# desp_df = pd.DataFrame({
#     "Cen√°rio": ["Atual","Simulado"],
#     "Despesa": [desp["atual"], desp["sim"]]
# })
# fig_d = go.Figure()
# fig_d.add_trace(go.Bar(x=desp_df["Cen√°rio"], y=desp_df["Despesa"], marker_color=["#1f77b4","#ff7f0e"]))
# fig_d.update_layout(height=260, yaxis_title="R$ (reais)")
# st.plotly_chart(fig_d, use_container_width=True)
# st.caption(f"Para o Limite M√°ximo (Simulado): Redu√ß√£o necess√°ria = {fmt_r(ajustes['M√°ximo']['reduce_R'])} ({ajustes['M√°ximo']['reduce_pct']:.2f}%)" if ajustes['M√°ximo']['reduce_R']>0 else "Para Limite M√°ximo: redu√ß√£o n√£o necess√°ria.")
# 
# # 3) Margens por limite (compara√ß√£o Atual vs Simulado)
# margens = {
#     "Limite": ["M√°x","Prud","Alerta"],
#     "Margem_Atual": [lim_atual[0]-desp["atual"], lim_atual[1]-desp["atual"], lim_atual[2]-desp["atual"]],
#     "Margem_Sim": [lim_sim[0]-desp["sim"], lim_sim[1]-desp["sim"], lim_sim[2]-desp["sim"]]
# }
# marg_df = pd.DataFrame(margens)
# fig_m = go.Figure()
# fig_m.add_trace(go.Bar(y=marg_df["Limite"], x=marg_df["Margem_Atual"], orientation='h', name="Margem Atual", marker=dict(color="lightblue")))
# fig_m.add_trace(go.Bar(y=marg_df["Limite"], x=marg_df["Margem_Sim"], orientation='h', name="Margem Simulado", marker=dict(color="lightcoral")))
# fig_m.update_layout(barmode='group', height=320, xaxis_title="Margem (R$)")
# st.plotly_chart(fig_m, use_container_width=True)
# st.caption("Margens (diferen√ßa entre limite e despesa). Valores negativos indicam extrapola√ß√£o.")
# 
# # 4) Receita x Despesa (scatter) com linhas de limite (do cen√°rio simulado)
# fig_sc = go.Figure()
# fig_sc.add_trace(go.Scatter(x=[rcl["atual"]], y=[desp["atual"]], mode="markers+text", text=["Atual"], textposition="top center", marker=dict(size=12, color="#1f77b4"), name="Atual"))
# fig_sc.add_trace(go.Scatter(x=[rcl["sim"]], y=[desp["sim"]], mode="markers+text", text=["Simulado"], textposition="top center", marker=dict(size=12, color="#ff7f0e"), name="Simulado"))
# # linhas horizontais dos limites (simulado)
# fig_sc.add_hline(y=lim_sim[0], line=dict(color="red", dash="dash"), annotation_text="Limite M√°x (Sim.)", annotation_position="bottom right")
# fig_sc.add_hline(y=lim_sim[1], line=dict(color="orange", dash="dot"), annotation_text="Limite Prud (Sim.)", annotation_position="bottom right")
# fig_sc.add_hline(y=lim_sim[2], line=dict(color="green", dash="dot"), annotation_text="Limite Alerta (Sim.)", annotation_position="bottom right")
# fig_sc.update_layout(title="Receita x Despesa (pontos Atual & Simulado)", xaxis_title="RCL Ajustada (R$)", yaxis_title="Despesa com Pessoal (R$)", height=420)
# st.plotly_chart(fig_sc, use_container_width=True)
# st.caption("Pontos indicam posi√ß√£o Atual e Simulado; linhas horizontais mostram limites do cen√°rio simulado.")
# 
# st.markdown("---")
# 
# # ---------- Tabela detalhada (Atual / Simulado) ----------
# st.header("üìã Tabela detalhada (Atual / Simulado)")
# rows = []
# for key in ["Atual","Simulado"]:
#     Lm, Lp, La = (lim_atual if key=="Atual" else lim_sim)
#     D = (desp["atual"] if key=="Atual" else desp["sim"])
#     R = (rcl["atual"] if key=="Atual" else rcl["sim"])
#     rows.append({
#         "Cen√°rio": key,
#         "RCL ajustada (R$)": R,
#         "Despesa Pessoal (R$)": D,
#         "Limite M√°x (R$)": Lm,
#         "Limite Prud (R$)": Lp,
#         "Limite Alerta (R$)": La,
#         "Margem M√°x (R$)": Lm - D,
#         "Margem Prud (R$)": Lp - D,
#         "Margem Alerta (R$)": La - D,
#         "% Ocup M√°x": (D / Lm * 100) if Lm else np.nan,
#         "% Ocup Prud": (D / Lp * 100) if Lp else np.nan,
#         "% Ocup Alerta": (D / La * 100) if La else np.nan,
#     })
# table_df = pd.DataFrame(rows)
# fmt_cols = {
#     "RCL ajustada (R$)": "{:,.2f}",
#     "Despesa Pessoal (R$)": "{:,.2f}",
#     "Limite M√°x (R$)": "{:,.2f}",
#     "Limite Prud (R$)": "{:,.2f}",
#     "Limite Alerta (R$)": "{:,.2f}",
#     "Margem M√°x (R$)": "{:,.2f}",
#     "Margem Prud (R$)": "{:,.2f}",
#     "Margem Alerta (R$)": "{:,.2f}",
#     "% Ocup M√°x": "{:.2f}%",
#     "% Ocup Prud": "{:.2f}%",
#     "% Ocup Alerta": "{:.2f}%"
# }
# st.dataframe(table_df.style.format(fmt_cols), height=240)
# 
# st.markdown("---")
# st.subheader("üì• Exportar tabela")
# csv_buf = io.StringIO()
# table_df.to_csv(csv_buf, index=False, sep=";")
# st.download_button("Baixar CSV (Detalhado)", csv_buf.getvalue().encode("utf-8"), file_name="margens_detalhado.csv", mime="text/csv")
# 
# st.caption("Notas: 'Atual' = situa√ß√£o atual; 'Simulado' = ap√≥s aplica√ß√£o da simula√ß√£o escolhida. Ajustes sugeridos s√£o valores para que a despesa passe a respeitar o limite.")
#

# C√©lula 3 corrigida ‚Äî inicia Streamlit e captura o link p√∫blico do cloudflared
import subprocess, time, sys, re

# 1) Inicia Streamlit em background (stdout ser√° capturado)
streamlit_cmd = [sys.executable, "-m", "streamlit", "run", "app.py",
                 "--server.port=8501", "--server.address=0.0.0.0"]
print("Iniciando Streamlit...")
st_proc = subprocess.Popen(streamlit_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

# D√° uma pequena pausa para o Streamlit come√ßar
time.sleep(4)

# 2) Inicia cloudflared (quick tunnel) e l√™ os logs em busca do link p√∫blico
print("Iniciando cloudflared (criando t√∫nel)...")
cf_proc = subprocess.Popen(
    ["cloudflared", "tunnel", "--url", "http://localhost:8501", "--no-autoupdate"],
    stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
)

# Regex para capturar o link trycloudflare
pattern = re.compile(r'https?://[^\s]*trycloudflare\.com[^\s]*', re.IGNORECASE)

url = None
start = time.time()
timeout = 60  # segundos para procurar o link automaticamente

print("Aguardando aparecer o link p√∫blico (pode levar alguns segundos)...\n(Se nada aparecer ap√≥s ~60s, verifique os logs abaixo.)\n")

# L√™ linhas do stdout do cloudflared at√© achar o link ou timeout
while True:
    line = cf_proc.stdout.readline()
    if line:
        print(line.strip())  # mostra logs √∫teis para diagn√≥stico
        m = pattern.search(line)
        if m:
            url = m.group(0)
            print("\n>>> LINK P√öBLICO ENCONTRADO:", url)
            break
    else:
        # se n√£o h√° nova linha, verifica se o processo terminou
        if cf_proc.poll() is not None:
            print("\ncloudflared terminou (verifique logs acima).")
            break
        # timeout para n√£o ficar preso indefinidamente
        if time.time() - start > timeout:
            print("\nTimeout: n√£o encontrei o link em ~60s. Verifique os logs acima.")
            break
        time.sleep(0.2)

if url:
    print("\nAbra o link acima no navegador (PC ou celular).")
else:
    print("\nSe n√£o encontrou o link, veja a sa√≠da de logs acima para buscar manualmente uma URL do tipo https://xxxx.trycloudflare.com")

print("\nProcessos em execu√ß√£o:")
print(f" - streamlit PID = {st_proc.pid}")
print(f" - cloudflared PID = {cf_proc.pid}")

print("\nPara encerrar manualmente, execute em outra c√©lula:")
print(f"!kill {st_proc.pid}  # para parar o Streamlit")
print(f"!kill {cf_proc.pid}  # para parar o cloudflared")